import { serve } from 'https://deno.land/std@0.177.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.43.1';
import { createHmac } from "https://deno.land/std@0.177.0/node/crypto.ts";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Garmin API endpoints
const ACTIVITIES_URL = 'https://apis.garmin.com/wellness-api/rest/activities';

// OAuth 1.0a signature generation
function generateOAuthSignature(
  method: string,
  url: string,
  params: Record<string, string>,
  consumerSecret: string,
  tokenSecret: string
): string {
  // Sort parameters
  const sortedParams = Object.keys(params)
    .sort()
    .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`)
    .join('&');

  // Create signature base string
  const signatureBaseString = `${method.toUpperCase()}&${encodeURIComponent(url)}&${encodeURIComponent(sortedParams)}`;

  // Create signing key
  const signingKey = `${encodeURIComponent(consumerSecret)}&${encodeURIComponent(tokenSecret)}`;

  // Generate signature
  const hmac = createHmac('sha1', signingKey);
  hmac.update(signatureBaseString);
  return hmac.digest('base64');
}

// Generate OAuth header
function generateOAuthHeader(
  method: string,
  url: string,
  consumerKey: string,
  consumerSecret: string,
  accessToken: string,
  tokenSecret: string
): string {
  const oauthParams: Record<string, string> = {
    oauth_consumer_key: consumerKey,
    oauth_token: accessToken,
    oauth_signature_method: 'HMAC-SHA1',
    oauth_timestamp: Math.floor(Date.now() / 1000).toString(),
    oauth_nonce: crypto.randomUUID().replace(/-/g, ''),
    oauth_version: '1.0',
  };

  // Generate signature
  const signature = generateOAuthSignature(method, url, oauthParams, consumerSecret, tokenSecret);
  oauthParams.oauth_signature = signature;

  // Build OAuth header
  const headerParams = Object.keys(oauthParams)
    .sort()
    .map(key => `${encodeURIComponent(key)}="${encodeURIComponent(oauthParams[key])}"`)
    .join(', ');

  return `OAuth ${headerParams}`;
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    console.log('üîÑ Starting Garmin manual sync...');

    // Get authenticated user
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      throw new Error('No authorization header');
    }

    const SUPABASE_URL = Deno.env.get('SUPABASE_URL');
    const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');
    const SUPABASE_ANON_KEY = Deno.env.get('SUPABASE_ANON_KEY');

    if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY || !SUPABASE_ANON_KEY) {
      throw new Error('Missing Supabase configuration');
    }

    // Get user
    const supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
      global: { headers: { Authorization: authHeader } }
    });

    const { data: { user }, error: userError } = await supabaseClient.auth.getUser();
    
    if (userError || !user) {
      throw new Error('User not authenticated');
    }

    console.log('üë§ User ID:', user.id);

    // Get Garmin connection
    const supabaseAdmin = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

    const { data: connection, error: connError } = await supabaseAdmin
      .from('garmin_connections')
      .select('*')
      .eq('user_auth_id', user.id)
      .maybeSingle();

    if (connError || !connection) {
      console.error('‚ùå No Garmin connection found');
      throw new Error('Garmin not connected. Please connect your Garmin account first.');
    }

    console.log('‚úÖ Found Garmin connection');

    // Get Garmin credentials
    const GARMIN_CLIENT_ID = Deno.env.get('GARMIN_CLIENT_ID');
    const GARMIN_CLIENT_SECRET = Deno.env.get('GARMIN_CLIENT_SECRET');

    if (!GARMIN_CLIENT_ID || !GARMIN_CLIENT_SECRET) {
      throw new Error('Garmin credentials not configured');
    }

    // Calculate time range (last 30 days)
    const endTime = Math.floor(Date.now() / 1000);
    const startTime = endTime - (30 * 24 * 60 * 60); // 30 days ago

    console.log(`üìÖ Fetching activities from ${new Date(startTime * 1000).toISOString()} to ${new Date(endTime * 1000).toISOString()}`);

    // Build request URL with query parameters
    const queryParams = `uploadStartTimeInSeconds=${startTime}&uploadEndTimeInSeconds=${endTime}`;
    const fullUrl = `${ACTIVITIES_URL}?${queryParams}`;

    // Generate OAuth 1.0a header
    const oauthHeader = generateOAuthHeader(
      'GET',
      ACTIVITIES_URL,
      GARMIN_CLIENT_ID,
      GARMIN_CLIENT_SECRET,
      connection.access_token,
      connection.token_secret
    );

    console.log('üîê Calling Garmin API...');

    // Call Garmin API
    const response = await fetch(fullUrl, {
      method: 'GET',
      headers: {
        'Authorization': oauthHeader,
      },
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('‚ùå Garmin API error:', response.status, errorText);
      throw new Error(`Garmin API error: ${response.status} - ${errorText}`);
    }

    const activities = await response.json();
    console.log(`üìä Received ${activities.length} activities from Garmin`);

    if (!activities || activities.length === 0) {
      return new Response(
        JSON.stringify({ 
          success: true, 
          message: 'No new activities found',
          activitiesImported: 0 
        }),
        { 
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 200 
        }
      );
    }

    // Process each activity (using same logic as webhook)
    let importedCount = 0;
    let skippedCount = 0;

    for (const activity of activities) {
      try {
        console.log(`\nüìä Processing activity: ${activity.activityName} (ID: ${activity.activityId})`);

        // Check if activity already exists
        const { data: existingActivity } = await supabaseAdmin
          .from('published_activities_simple')
          .select('id')
          .eq('garmin_activity_id', activity.activityId.toString())
          .maybeSingle();

        if (existingActivity) {
          console.log(`‚ö†Ô∏è Activity ${activity.activityId} already exists, skipping`);
          skippedCount++;
          continue;
        }

        // Map activity type
        const workoutType = mapGarminActivityType(activity.activityType);
        
        // Convert distance from meters to kilometers
        const distanceKm = activity.distanceInMeters 
          ? Math.round(activity.distanceInMeters / 1000 * 100) / 100 
          : 0;

        // Convert duration to HH:MM:SS format
        const duration = formatDuration(activity.durationInSeconds);

        // Convert start time to ISO string
        const activityDate = new Date(activity.startTimeInSeconds * 1000).toISOString();

        // Prepare activity data
        const activityData = {
          user_id: user.id,
          title: activity.activityName || `${activity.activityType} Activity`,
          description: `Imported from Garmin - ${activity.deviceName || 'Unknown device'}`,
          distance: distanceKm,
          duration: duration,
          calories: activity.activeKilocalories || null,
          workout_type: workoutType,
          is_public: false,
          garmin_activity_id: activity.activityId.toString(),
          imported_from_garmin: true,
          activity_date: activityDate,
          gps_points: [],
          created_at: new Date().toISOString(),
        };

        console.log('üíæ Saving activity to database...');

        // Insert activity
        const { data: savedActivity, error: insertError } = await supabaseAdmin
          .from('published_activities_simple')
          .insert(activityData)
          .select()
          .single();

        if (insertError) {
          console.error('‚ùå Error inserting activity:', insertError);
          continue;
        }

        console.log(`‚úÖ Activity saved successfully: ${savedActivity.id}`);
        importedCount++;

        // Check if this completes a workout in the plan
        await checkAndCompleteWorkout(
          supabaseAdmin,
          user.id,
          workoutType,
          distanceKm,
          activity.durationInSeconds / 60,
          activityDate
        );

      } catch (activityError) {
        console.error(`‚ùå Error processing activity ${activity.activityId}:`, activityError);
      }
    }

    console.log(`\n‚úÖ Sync completed: ${importedCount} imported, ${skippedCount} skipped`);

    return new Response(
      JSON.stringify({ 
        success: true, 
        message: `Successfully imported ${importedCount} activities`,
        activitiesImported: importedCount,
        activitiesSkipped: skippedCount
      }),
      { 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200 
      }
    );

  } catch (error) {
    console.error('‚ùå Error in garmin-sync:', error);
    
    return new Response(
      JSON.stringify({ 
        error: error.message || 'Unknown error',
        success: false
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 400,
      },
    );
  }
});

// Helper functions (same as webhook)

function mapGarminActivityType(garminType: string): string {
  const typeMap: Record<string, string> = {
    'RUNNING': 'carrera',
    'TRAIL_RUNNING': 'carrera',
    'TREADMILL_RUNNING': 'carrera',
    'TRACK_RUNNING': 'carrera',
    'VIRTUAL_RUN': 'carrera',
    'CYCLING': 'ciclismo',
    'ROAD_BIKING': 'ciclismo',
    'MOUNTAIN_BIKING': 'ciclismo',
    'GRAVEL_CYCLING': 'ciclismo',
    'VIRTUAL_RIDE': 'ciclismo',
    'INDOOR_CYCLING': 'ciclismo',
    'WALKING': 'caminata',
    'HIKING': 'caminata',
    'CASUAL_WALKING': 'caminata',
    'SWIMMING': 'natacion',
    'LAP_SWIMMING': 'natacion',
    'OPEN_WATER_SWIMMING': 'natacion',
    'STRENGTH_TRAINING': 'entrenamiento',
    'CARDIO': 'entrenamiento',
    'YOGA': 'entrenamiento',
  };

  return typeMap[garminType] || 'otro';
}

function formatDuration(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = seconds % 60;
  
  return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(Math.floor(secs)).padStart(2, '0')}`;
}

async function checkAndCompleteWorkout(
  supabase: any,
  userId: string,
  workoutType: string,
  distanceKm: number,
  durationMinutes: number,
  activityDate: string
) {
  try {
    console.log('üîç Checking for matching workout in plan...');

    const { data: activePlan } = await supabase
      .from('training_plans')
      .select('id, current_week')
      .eq('user_id', userId)
      .eq('is_active', true)
      .maybeSingle();

    if (!activePlan) {
      console.log('‚ÑπÔ∏è No active plan found');
      return;
    }

    const activityDateOnly = activityDate.split('T')[0];
    
    const { data: matchingWorkout } = await supabase
      .from('simple_workouts')
      .select('id, distance_km, duration_minutes')
      .eq('user_id', userId)
      .eq('plan_id', activePlan.id)
      .eq('completed', false)
      .eq('workout_type', workoutType)
      .gte('workout_date', activityDateOnly)
      .order('workout_date', { ascending: true })
      .limit(1)
      .maybeSingle();

    if (!matchingWorkout) {
      console.log('‚ÑπÔ∏è No matching incomplete workout found');
      return;
    }

    const distanceTolerance = matchingWorkout.distance_km * 0.1;
    const distanceMatch = Math.abs(distanceKm - matchingWorkout.distance_km) <= distanceTolerance;

    if (distanceMatch) {
      console.log(`‚úÖ Marking workout ${matchingWorkout.id} as completed`);
      
      const { error: updateError } = await supabase
        .from('simple_workouts')
        .update({
          completed: true,
          actual_distance_km: distanceKm,
          actual_duration_minutes: durationMinutes,
          completed_at: activityDate
        })
        .eq('id', matchingWorkout.id);

      if (updateError) {
        console.error('‚ùå Error updating workout:', updateError);
      } else {
        console.log('‚úÖ Workout marked as completed');
      }
    } else {
      console.log(`‚ÑπÔ∏è Distance doesn't match (expected: ${matchingWorkout.distance_km}km, got: ${distanceKm}km)`);
    }

  } catch (error) {
    console.error('‚ùå Error checking workout completion:', error);
  }
}




